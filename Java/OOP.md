# 객체지향 프로그래밍 이해
1. 절차 지향 프로그래밍
    - 객체지향 언어 개념이 나오면서 기존 프로그래밍 방식을 표현하기 위해서 사용
    - 큰 틀은 일렬의 동작(모듈, 함수)를 순서에 맞게 단계적으로 실행
    - 데이터와 속성 보다는 명령어의 순서와 흐름에 포커싱
    - 소프트웨어 규모가 커지면서 기능들이 복잡해지면서 추가 개발이나 유지보수의 어려움
    - 절차적 프로그래밍 이라고도 하며 구조적 프로그래밍이라고도 한다.
***
2. 절차 지향 프로그래밍
    - 클래스라는 개념을 도입한 프로그래밍 방법론
    - 클래스를 생성하고 클래스로부터 객체를 만들어 객체 간의 상호작용을 이용하여 주어진 문제를 해결
    - 데이터인 필드와 절차인 메소드를 하나로 묶은 클래스 단위의 프로그램
    - 현실 세계를 객체 단위로 프로그래밍하여, 객체는 필드(데이터)와 메서드(코드)를 하나의 블럭으로 묶어 표현
***
3. 객체 - 현실 세계의 사물이나 개념을 시스템에서 이용하기 위해 현실 세계를 자연스럽게 표현하여 손쉽게 이용 할 수 있도록 만든 소프트웨어 모델
    + 속성(attributes,properties) + 행동(messages,behaviors)
        - 속성 - 객체의 특성을 표현하는 정적인 성질,프로그래밍에서 속성은 필드
        - 행동 - 객체 내부의 일을 처리하거나 객체들 간의 서로 영향을 주고 받는 동적인 일을 처리하는 단위, 메소드
***
4. 클래스와 객체
    + 클래스 - 객체를 만들기위한 모형이자 틀
    + 객체 - 클래스의 구체적인 하나의 실체(instance)
***
5. 객체 지향 언어의 4가지 특징
    + 추상화
        - 사물을 객체화 하는것
        - 모든 것을 추상화 하지 않는다.
        - 딱 필요한 부분만 클래스로 만드는 작업(attribute와 method로 구체화)
    + 캡술화
        - 기능을 숨기는 것
        - 객체와 객체 간의 의사 소통을 위한 정보만을 노출 => 모든 걸 숨긴다는 것은 아님
        - 추상화 과정에서 클래스를 정의 할 때, 자료와 행위를 클래스 단위로 하나로 묶고, 실제 내부 구현 내용을 외부에 감추는것
        - 정보 은닉(캡슐화 과정에서 클래스 내부 구현을 외부에 숨김)
    + 상속
        - 기능을 물려 받는 것
        - 객체 지향의 가장 핵심이 되는 개념
        - 프로그램을 쉽게 확장할 수 있도록 해주는 강력한 수단
        -  상위 클래스와 하위 클래스 간의 관계
        - 공통의 특성을 하위 클래스 마다 반복적으로 기술하지 않고 한 번만 기술하기 때문에 중복을 줄여 재사용성의 효과
    + 다형성
        - 같은 기능을 서로 다르게 다양하게 기능하도록 하는 것
        - 외부에 보이는 모습은 한 가지 형태이지만 실질적으로 쓰이는 기능은 여러가지 역할을 수행한다는 의미
        - 오버 로딩과 오버 라이딩과 같은 느낌
***
6. 메소드 지정자
    + final - 메소드 재정의 제한
        - 상속을 받은 자식클래스에서 메소드를 더이상 재정의 할 수 없도록 제한함
    + static - 정적
        - 메소드의 소속을 클래스로 지정할 때
    + abstract - 추상
        - 메소드를 추상 메소드로 지정할 때
    + synchronized - 동기
        - 멀티쓰레드에서 메소드 동기화를 지정할 때
***
7. 클래스와 객체의 생성
    + new 키워드를 통해 생성 되는데, new 한느 순간 메모리에 할당이 된다.
***
8. getter와 setter
    + 감춰진 데이터(private,portected)의 값을 가져오거나 할당하는 특수한 메소드
    ```Java
        public class class1{
            private long data1;
            public String data2;

            //setter
            public void setData1(long data1){
                this.data1 = data1;
            }

            //getter
            public long getData1(){
                return data1;
            }
        }
    ```
***
9. 생성자
    + 객체를 만드는 틀인 클래스에서 필요하면 생성자를 구현
        - 객체가 생성될 대 필요한 작업을 수행하는 특별한 메소드
        - 주로 객체 필드에 초기 값을 저장하거나 객체의 사용을 위해 필요한 초기화 작업이 수행
    + 생성자의 구성
        - 반환형을 기술하지 않으며 이름은 반드시 클래스 이름
        - 생성자의 인자는 필요하면 기술
        - 생성자는 주로 접근 지정자 public을 사용
            - 만일 필요하다면 생성자의 접근 지정자도 private 또는 protected도 가능 -> 보통 singleton 패턴에서 사용
    + 기본 생성자 - 클래스를 정의할 때 기본적으로 생성 되는 생성자, 없다면 알아서 만들어 준다. 하지만 사용자가 직접 생성자를 만드는 순간 기본 생성자는 사라지기 때문에, 맘 편히 기본 생성자를 미리 만들어 놓고 사용하자
***
10. static과 final
    + static - 필드나 메소드의 소소을 클래스로 제한하는 키워드
        - static을 사용한 정적 변수나 정적 메소드는 클래스 변수와 클래스 메소드
        - 간단히 말하면 계속해서 사용될 상수 같은 것(원주율 PI = 3.141592)들을 객체 자체의 메모리에 할당 하는게 아니라 클래스에 메모리를 할당하고 사용 하는 것
        ```Java
            public class Circle{
                //Circle 마다 반지름이 다름
                double radius;
                //고정적으로 사용하는 값
                static double PI = 3.141592;
            }
        ```
    + final - 지역변수의 상수
        - 저장된 값을 더이상 수정 할 수 없도록 함
        - 소속된 변수인 필드를 상수로 선언하기 위해 사용(static도 함께 사용하여 정적으로 사용 할 것)
        ```Java
            public class Canlender{
                //이는 매번 생성할 때마다 메모리에 할당할 필요도 없고 변할 일도 없다.
                public int LAST_MONTH = 12;
                //따라서 정적 변수이 면서 변할 수 없도록 static final로 선언
                public static final int LAST_MONTH = 12;
                //아래와 같이 final만 쓰는 경우는 객체 생성시 딱 한번 할당이 필요 할때 사용 할 수 있다.
                public final int LAST_MONTH;
                public Canlender(){
                    LAST_MONTH = 12;
                }
            }
        ```
    + 멤버 변수의 초기화 방법
        - 명시적 초기화 - 변수가 선언될 때 초기화 되는 것 - 1순위
        - 초기화 블럭
            - 클래스 초기화 블럭 - 클래스 변수(static 변수)를 초기화 하는데 사용, 즉 한번만 불림 - 2순위
            - 인스턴스 초기화 블럭 - 인스턴스 변수를 초기화 하는데 사용, 해당 클래스의 인스턴스가 생성될 때 마다 호출 - 3순위
            ```Java
                public class exam{
                    static {
                        /*클래스 초기화 블럭*/
                    }

                    {
                        /*인스턴스 초기화 블럭*/
                    }
                }
            ```
        - 생성자 - 4순위
***
11. 배열 - 같은 자료형의 여러 변수를 하나의 묶음 으로 선언해서 처리 하는 것
    + 배열의 선언과 생성
    ```Java
        //배열의 선언
        int[] data1;
        String[] data2;

        int data3[];
        String data4[];
        //배열의 초기화
        int[] arr1 = new int[5];
        arr[0] = 10;
        arr[1] = 20;
        arr[2] = 30;
        arr[3] = 40;
        arr[4] = 50;
    ```
    + 배열의 길이 변경을 하려면 더큰 배열을 생성 해서 기존 내용을 복사는 방법을 사용 해야함
        - 깊은 복사와 얇은 복사
        - 단순히 배열에만 국한되는게 아니라 모든 클래스와 인스턴스에도 해당된다.
        ```Java
            int[] arr1 = new int[3];
            arr1[0] = 1;
            arr1[1] = 2;
            arr1[2] = 3;

            //이것은 arr2에 arr1 자체를 복사 하는 게 아니라 arr1이 할당된 메모리 주소를 arr2도 가리킨다는 뜻이다.
            int[] arr2 = arr1;

            //따라서 복사 하려면
            //for문을 다 돌면서 복사 해줘야 된다.
            int[] arr3 = new int[3];
            for(int )
                ...
        ```
***
12. 상속 - 하위 클래스는 상위 클래스의 특징인 필드와 메소드를 그대로 물려 받을 수 잇는 특성
    + 자바는 다중 상속을 지원하지 않는다.
    + 상속을 함으로써 상위 클래스의 멤버변수와 메서드를 접근 지정자를 통해 하위 클래스에서 사용 할지 말지를 정할 수 있다.
    ```Java
        //부모 클래스, 상위 클래스, 슈퍼 클래스, 기본 클래스
        //모든 클래스의 상위 클래스는 Object클래스
        public class Man {

        }
        //자식 클래스, 하위 클래스, 서브 클래스
        //extends 키워드로 상속 표현
        public class SchoolStaff extends Man {

        }
    ```
    + super()는 상위 클래스의 기보 생성자를 호출하는 문장이다.
        - 생성자의 첫줄에서 상위 생성자를 호출하는 super()를 명시적으로 호출하지 않는다면 첫줄에서 무조건 자동으로 super()를 호출한다.
    + 업 캐스팅
        - 하위 객체는 상위 클래스형 변수에 대입이 가능, 상위로의 자료형 변환
        - 업캐스팅은 항위인 교지원은 상위인 사람이라는 개념이 성립
        - 제약
            - 업 캐스팅된 변수로는 하위 객체의 멤버를 참주 할 수 없다.
            - 교직원 변수 김사랑은 접근 지정자만 허용한다면 모든 멤버에 접근 가능
            - 사람 변수 김사람은 사람의 멤버만 접근 가능
    + 다운 캐스팅
        - 상위 클래스형을 하위 클래스 형으로 변환
        - 다운 캐스팅은 반드시 명시적 형변환 연산자 (하위 클래스)가 필요
        - 만일 형변환 연산자가 없으면 컴파일 시간에 오류 발생
***
13. 추상클래스와 인터페이스 다시 듣기!
***
14. Java 클래스 및 라이브러리 활용
    + java.lang 패키지
        - 자바 프로그램의 가장 기본이 되는 클래스들을 포함
        - import문 없이 사용
        - 대표적인 String, System 클래스를 import문 없이 사용할 수 있었던 이유
    + Object 클래스
        - 모든 클래스의 조상 클래스 -> 따라서 Object 클래스의 멤버들은 상송이 가능하다면 다른 클래스에서 사용가능
            - 메소드
                - clone - 객체 자신의 복사본을 리턴
                - equals - 객체 자신과 같은 객체인지를 리턴
                - finalize - 소멸될 때 실행
                - getClass - 객체 자신의 클래스 정보를 담고 있는 Class인스턴스 반환
                - hashCode - 해시코드를 반환
                - toString - 문자열 리턴
                - notify - 객체 자신을 사용하려고 기다리는 쓰레드를 하나만 깨운다.
                - notifyAll - 객체 자신을 사용하려고 기다리는 모든 쓰레드를 깨운다.
***
15. String 클래스
    + String Class
        - 자바에서 문자열을 처리하는 클래스
        - 메서드
            - length
            - charAt
            - toCahrArray
            - contains
            - indexOf
            - lastIndexOf
            - toLowerCase
            - toUpperCase
            - trim
            - equals 등등 오지게 많음으로 필요할 때마다 검색
***
16. StringBuffer 클래스
    - 문자열 처리는 보통 Stringdl 하지만, 불변의 속성을 갖는다.
    - 문자열을 할닫했다가, 추가로 더해지는 연산을 하면 기존 메모리에 추가되는게 아니라,<br>새로운 메모리에 더해진 문자열의 영역을 잡고 그곳의 주소를 가리킨다, 즉 메모리 낭비가 발생한다
    - 위를 해결하기 위해 불변이 아닌 가변의 속성을 가지는 StringBuffer 클래스를 사용한다.
    - 따라서 문자열의 변경이 빈번하게 발생하는 경우 String 클래스 보다는 StringBuffer 클래스를 사용한다.
***
17. Math 클래스
    + 수학 계산 하는데 있어서 유용한 클래스
    + 소수점 처리함수
        - round : 반올림
        - ceil : 올림
        - floor : 버림
***
18. 날짜 관련 클래스
    + 날짜와 시간의 데이터를 처리하기 위해서 Date 클래스 이용
    + JDK1.0부터 제공하는 클래스 -> 현재 대부분의 레거시 시스템 소스에 묻어 잇다.
    + 이후 기능 추가한 Calendar 클래스 포함
    + JDK1.8에 와서 java.time 패키지에 기존 기능 개선된 클래스 추가(대표적으로 LocalDate,LocalDateTime)
    + 완전 새로운 시스템을 구축하지 않는 이상, Date 클래스는 사용 안할 수는 없음
    + Calendar 클래스 이후, 대부분의 메서드는 Calendar에서 가져오고 Date는 저장의 용도로만 사용
***
19. 제네릭 클래스
    + 일반적이라는 의미로 하나의 코드로 여러 타입을 동시에 처리하는 기술
    + 다양한 종류의 데이터를 처리할 수 있는 클래스와 메소드를 작성하는 기법
    + JDK 1.5부터 사용
    + 클래스를 정의할 때 클래스 안에서 사용하는 자료형을 구체적으로 명시하지 않고 T와 같은 기호로 표시
    + 이후 객체를 생성할 때 T 자리에 구체적인 자료형을 적어줌
    + 타입 변수 표기법
        - 제네릭 클래스는 여러개의 타입 매개 변수를 가질 수 있으나 타입의 이름은 클래스나 인터페이스 내에서 유일해야함
        - 한개의 대문자로 표시하는게 관례
        - 타입 매개 변수는 기초 자료형으로 객체화될 수 없음
    + 제네릭 메소드
        - 일반 클래스의 메소드에서도 타입 매개 변수를 사용하여 제네릭 메소드를 정의, 이때 타입 매개변수의 범위는 메소드 내부로 제한됨
    ```Java

    ```
***
20. 컬렉션
    + 자바에서 자료 구조를 구현한 클레스
    + 자료 구조란 자료를 저장하기 위한 구조
    + 대부분의 프로그램은 자료를 저장하기 때문에 필요에 따라서 적절한 자료 구조를 사용할 지를 결정
        - 전화 번호를 저장
        - 시간표를 저장
    + 자료구조의 종류 : 리스트, 스텍, 큐, 집합, 해시 테이블 등
    + Vector 클래스
        - 벡터 클래스는 Java에서 가장 오래된 자료구조 구현 클래스
        - 배열의 경우, 크기가 고정되어 있기 때문에 사용이 불편함
        - Vector는 가변 크기의 배열을 구현
        - 요소의 개수가 늘어나면 자동으로 배열의 크기가 늘어남
        - 어떤 타입의 객체도 저장
        ```Java
            Vector vector = new Vector();

            //벡터 삽입
            vector.add("홍길동");
            vector.add(1);
            vector.add(25);
            vector.add("동");

            //백터의 원소 접근
            vector.get(0);
            vector.get(1);
            vector.get(2);
            vector.get(3);

            //벡터의 원소 순회
            for(Object x: vector) {
                System.out.println(x);
            }
        ```
    + Set 클래스
        - HashSet : 키값만 중복 안되는 Set
        - LinkedHashSet : 넣는 순서되로 Set
        - TreeSet : 정렬된 Set
        ```Java
            HashSet<String> hashSet = new HashSet<String>();
            LinkedHashSet<String> linkedHashSet = new LinkedHashSet<>();
            TreeSet<String> treeSet = new TreeSet<>();

            hashSet.add("4");
            hashSet.add("2");
            hashSet.add("3");
            hashSet.add("1");
            hashSet.add("4");
            
            Iterator<String> hashSetIterator = hashset.iterator();
            while(hashSetIterator.hasNext()){
                System.out.println(hashSetIterator.next())
            }
            hashSet.add("4");
        ```
    + Map 클래스 - Set과는 다르게 키와 값을 가짐
        - HashMap: 그냥 키값만 중복 안되게
        - LinkedHashMap : 넣는 순서 대로
        - TreeMap : 정렬
        ```java
            HashMap<String, Object> hashMap = new HashMap<>();
            LinkedHashMap<String, Object> linkedHashMap = new LinkedHashMap<>();
            TreeMap<String, String> treeMap = new TreeMap();

            hashMap.put("B","B-Value");
            hashMap.put("A","A-Value");
            hashMap.put("D","D-Value");
            hashMap.put("C","C-Value");
            hashMap.put("B","B-Value");
        ```
    + 리스트
        - ArrayList:순차적인 추가 삭제는 빠르지만, 중간에 있는 데이터를 추가, 삭제하는 경우에는 LinkedList에 비해 상식적으로 느림, 추가 삭제를 반복할 경우 메모리 사용잉 비효율 적
        - LinkedList:데이터를 처리하는데 있어서 개수가 계속해서 변하는 경우는 LinkedList를 사용하고 그 이외에는 대부분 ArrayList를