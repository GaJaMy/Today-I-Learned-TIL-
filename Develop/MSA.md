# MSA (Microservice Architecture)

## 모놀로식 아키텍쳐(Monolithic Architecture)
전통적인 개발 방식으로 하나의 프로젝트에 모든 기능을 함께 포함

### 장점
- 초기 개발에 유리하며 빠르게 프로토타입을 개발 가능
- 필요한 모든 기능을 한 번만 호출하기 때문에 복잡한 통신 없이 직접 사용 가능

### 단점
- 코드 베이스가 커질수록 복잡해지고 유지 관리 및 확장이 어려움
- 일부 기능을 수정하거나 업테이트를 하려면 전체 어플리케이션을 재배포 해야함


## 마이크로서비스 아키텍쳐 (MicroService Architecture)
여러 개의 작은 서비스로 구성되어 각 서비스가 독립적으로 개발되고 배포되는 구조로 MSA로 구성되어 있는 애플리케이션의 경우 전체 시스템이 분산되어 있어 개발, 배포가 독립적으로 가능하며 확장성과 유지관리가 용이

각 서비스는 독립적인 계층을 가지고 DB를 가진다.

### 장점
- 서비스 간 독립성으로 인해 확장성과 유연성이 높아진다.
- 기능 고립성이라는 특징 때문에 일 부 서비스가 실패하더라도 전체 시스템에 큰 영향을 미치지 않는다.

### 단점
- 서비스 간 통신이 필요하며, 서로 간 연결 구축 및 관리의 복잡성이 증가한다.
- 초기 개발 및 통신 등에 시간이 소요된다.


## 트렌젝션
MSA의 각 서비스는 독립적인 계층과 DB를 가진다. 그렇다면 하나의 서비스에 여러 DB를 참조하고 수정하는 일이 발생한다면 트렌젝션이 어떻게 처리되어야 하며, 관리가되어야 할까?

기존의 모놀리식 구조에서는 각 도메인 뿐만 아니라 도메인을 영속화하는 DB까지 하나의 어플리케이션에 존재, 따라서, 별도의 설정을 하지 않으면 하나의 요청을 처리할 때 하나의 트랜잭션으로 묶여 처리

분산 환경인 MSA 환경에서는 DB가 분리되어 있기 때문에 물리적 트랜잭션이 같을 수가 없는데 어떻게 원자성을 보장 할 수 있을까?

이 트랜잭션을 관리하는 방법으로 2가지 가 존재 한다.

### 2PC 패턴(2Phase Commit 패턴)
2PC 패턴은 분산 환경에서 트랜잭션의 원자성을 보장하기 위한 패턴으로 자세한 정의는 다음과 같다.

#### 정의
트랜잭션 처리, 데이터베이스, 컴퓨터 네트워크에서 2단계 커밋 프로토콜은 원자적 커밋 프로토콜의 일종으로 트랜잭션을 커밋할지, 아니면 롤벡할지에 대해 분산 원자적 트랜잭션에 관여하는 분산 알고리즘의 하나이다.

#### 특징
- 분산 트랜잭션을 관리하는 주체인 Coordinator가 있다.
    - Spring에서는 JTA라는 인터페이스를 사용 
    - 대표적으로 Atomikos
- 이름에서도 알 수 있듯이 2가지 Phase가 존재한다.
    - Prepare Phase
    - Commit Phase


- Prepare Phase
    1. Coordinator가 모든 참여자에게 준비 되었는지 메시지를 보냄
    2. 참여자는 자신의 DB 트랜잭션을 커밋 직전 상태로 만들고 OK/NO 응답
- Commit Phase
    1. 모든 참여자가 OK를 응답하면, Coomit 명령을 내려 모두가 확정
    2. 하나라도 No를 응답하면, Coordinator가 Rollback 명령을 내려 모두 취소


### SAGA 패턴
분산 환경에서 하나의 작업이 여러 서비스에 걸쳐 실행 될 때, 트랜잭션 일관성을 보장하는 방법으로 2PC 처럼 모든걸 동시에 Commit/Rollback 하는게 아니라, 로컬 트랜잭션 + 보상 트랜잭션으로 처리

#### 특징
1. 각 서비스는 자신의 DB에서만 로컬 트랜잭션을 실행
2. 만약 실패하면 이미 실행된 서비스들의 작업을 취소(보상)하는 API를 호출

- 두 가지 스타일
    1. Choreography (안무형)
        - 중앙 오케스트레이터 없음
        - 서비스들이 이벤트를 서로 구독/발행해서 Saga 진행
        - 간단하지만 복잡해지면 흐름 추적이 어려움
    2. Orchestration (오케스트레이션형)
        - 중앙 "Saga Orchestrator"가 전체 흐름을 관리
        - Orchestrator가 "회원 확인 -> 상품 등록 -> 결제" 같은 흐름을 순차적으로 지휘
        - 실패 시 Orchestrator가 보상 트랜잭션 실행 지시


