# 알고리즘
1. 알고리즘 이란
    - 어떤 문제 해결을 위한 절차나 방법
    - 조건
        - 입력
        - 출력
        - 명확성
        - 유한성
        - 효율성
    - 좋은 알고리즘
        - 정확성
        - 시간 복잡도
        - 공간 복잡도
***
2. 정렬(Sort)
    + 특정 값을 기준으로 데이터를 순서대로 배치하는 방법
    + 구현 난이도는 쉽지만 속도는 느린 알고리즘
        - 버블 정렬, 삽입 정렬, 선택 정렬
    + 구현 난이도는 조금 더 어렵지만, 속도는 빠른 알고리즘
        - 합병 정렬, 힙 정렬, 퀵 정렬, 트리 정렬
    + 하이브리드 정렬
        - 팀 정렬, 블록 병합 종렬, 인트로 정렬
    + 기타 정렬 알고리즘
        - 기수 정렬, 카운팅 정렬, 셀 정렬, 보고 정렬
***
+ 느린 정렬
    1. 버블 정렬
        + 인접한 데이터를 비교하며 자리 바꾸는 방식
        + 알고리즘 복잡도 O(N^2)
            - 첫번째와 두번째 수를 비교 해서 작은 건 앞으로 보내는데, 이 스탭을 N번 반복
    2. 삽입 정렬
        + 앞의 데이터를 정렬 해가면서 삽입 위치를 찾아 정렬하는 방식
        + 알고리즘 복잡도 O(N^2)
            - 자기 앞의 데이터 들과 모두 비교해 보면서 삽입해주는 정렬
        + 평균 적으로 버블보다는 빠름
    3. 선택 정렬
        + 최소 또는 최대 값을 찾아서 가장 앞 또는 뒤부터 정렬하는 방식
        + 알고리즘 복잡도 O(N^2)
+ 빠른 정렬
    1. 합병 정렬(Merge Sort)
        + 배열을 계속 분할해서 길이가 1이 되도록 만들고, 인접한 부분끼리 정렬하면서 합병하는 방식
        + 알고리즘 복잡도 O(NlogN)
    2. 힙 정렬
        + 힙 자료구조 형태의 정렬 방식
        + 기존 배열을 최대 힙으로 구조 변경 후 정렬 진행
        + 알고리즘 복잡도 O(NlogN)
    3. 퀵 정렬
        + 임의의 기준 값을 정하고 그 값을 기준으로 좌우 분할하며 정렬하는 방식
        + 알고리즘 복잡도 O(N^2)
    4. 트리 정렬
        + 이진 탐색 트리(BST)를 만들어 정렬하는 방식
        + 알고리즘 복잡도 O(NlogN)
+ 기타 정렬
    1. 기수 정렬
        + 낮은 자리 수부터 정렬하는 방식
        + 각 원소 간의 비교 연산을 하지 않아 빠른 대신, 기수 테이블을 위한 메모리 필요
        + 알고리즘 복잡도 O(dN) - d: 최대 자리수
    2. 계수 정렬
        + 숫자 끼리 비교하지 않고 카운트를 세서 정렬하는 방식
        + 카운팅을 위한 메모리 필요
        + 알고리즘 복잡도 O(N+K) - k : 정렬 데이터 중 최대값
    3. 셸 정렬
        + 삽입 정렬의 약점 보완한 정렬 방식
        + 삽입 정렬의 약점
            - 오름차순 정렬 기준, 내림차순으로 구성된 데이터에 대해서는 앞의 데이터와 하나씩 비교하며 모두 교환 필요
        + 이전의 모든 데이터와 비교하지 않고 일정 간격을 드어 비교
        + 알고리즘 복잡도 O(N^2)
***
3. 이진 탐색
    + 정렬된 상태의 데이터에서 특정 값을 빠르게 탐색하는 방법
        - 찾고자 하는 값과 데이터 중앙에 있는 값을 비교
        - 찾고자 하는 값이 더 작으면 데이터 왼쪽 부분에서 이진 탐색
        - 찾고자 하는 값이 더 크면 데이터 오른쪽 부분에서 탐색
4. 투 포이터
    + 배열 에서 두개의 포인터를 사용하여 워하ㅡ 결과를 어드 방법
    + 두 개 포인터의 배치 방법
        - 같으 방향에서 시작 : 첫 번째 원소에 둘 다 배치
        - 서로 다른 방향에서 시작 : 첫 번 째 원소와 마지막 원소에 배치
    + 다중 for 문의 복잡도를 좀 더 선형적으로 풀 수 있음
5. 그리디 알고리즘
    + 매 순간 현재 기준으로 최선의 답을 선택해 나가는 기법
        - 빠르게 근사치를 계산할 수 있다
        - 결과적으로는 최적해가 아닐 수도 있다.
    + 그리디 알고리즘 적용 조건
        - 그리디 알고리즘은 빠르지만 최적해를 보장하지는 못함
        - 하기 두가지 조건에 해당하는 경우 적용 간능
            - 탐욕적 선택 특성
                - 지금 선택이 다음 선택에 영향을 주지 않음
            - 최적 부분 구조
                - 전체 문제의 최적해는 부분 문제의 최적해로 이루어짐