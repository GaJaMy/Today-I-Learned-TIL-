# 알고리즘
1. 알고리즘 이란
    - 어떤 문제 해결을 위한 절차나 방법
    - 조건
        - 입력
        - 출력
        - 명확성
        - 유한성
        - 효율성
    - 좋은 알고리즘
        - 정확성
        - 시간 복잡도
        - 공간 복잡도
***
2. 정렬(Sort)
    + 특정 값을 기준으로 데이터를 순서대로 배치하는 방법
    + 구현 난이도는 쉽지만 속도는 느린 알고리즘
        - 버블 정렬, 삽입 정렬, 선택 정렬
    + 구현 난이도는 조금 더 어렵지만, 속도는 빠른 알고리즘
        - 합병 정렬, 힙 정렬, 퀵 정렬, 트리 정렬
    + 하이브리드 정렬
        - 팀 정렬, 블록 병합 종렬, 인트로 정렬
    + 기타 정렬 알고리즘
        - 기수 정렬, 카운팅 정렬, 셀 정렬, 보고 정렬
***
+ 느린 정렬
    1. 버블 정렬
        + 인접한 데이터를 비교하며 자리 바꾸는 방식
        + 알고리즘 복잡도 O(N^2)
            - 첫번째와 두번째 수를 비교 해서 작은 건 앞으로 보내는데, 이 스탭을 N번 반복
    2. 삽입 정렬
        + 앞의 데이터를 정렬 해가면서 삽입 위치를 찾아 정렬하는 방식
        + 알고리즘 복잡도 O(N^2)
            - 자기 앞의 데이터 들과 모두 비교해 보면서 삽입해주는 정렬
        + 평균 적으로 버블보다는 빠름
    3. 선택 정렬
        + 최소 또는 최대 값을 찾아서 가장 앞 또는 뒤부터 정렬하는 방식
        + 알고리즘 복잡도 O(N^2)
+ 빠른 정렬
    1. 합병 정렬(Merge Sort)
        + 배열을 계속 분할해서 길이가 1이 되도록 만들고, 인접한 부분끼리 정렬하면서 합병하는 방식
        + 알고리즘 복잡도 O(NlogN)
    2. 힙 정렬
        + 힙 자료구조 형태의 정렬 방식
        + 기존 배열을 최대 힙으로 구조 변경 후 정렬 진행
        + 알고리즘 복잡도 O(NlogN)
    3. 퀵 정렬
        + 임의의 기준 값을 정하고 그 값을 기준으로 좌우 분할하며 정렬하는 방식
        + 알고리즘 복잡도 O(N^2)
    4. 트리 정렬
        + 이진 탐색 트리(BST)를 만들어 정렬하는 방식
        + 알고리즘 복잡도 O(NlogN)
+ 기타 정렬
    1. 기수 정렬
        + 낮은 자리 수부터 정렬하는 방식
        + 각 원소 간의 비교 연산을 하지 않아 빠른 대신, 기수 테이블을 위한 메모리 필요
        + 알고리즘 복잡도 O(dN) - d: 최대 자리수
    2. 계수 정렬
        + 숫자 끼리 비교하지 않고 카운트를 세서 정렬하는 방식
        + 카운팅을 위한 메모리 필요
        + 알고리즘 복잡도 O(N+K) - k : 정렬 데이터 중 최대값
    3. 셸 정렬
        + 삽입 정렬의 약점 보완한 정렬 방식
        + 삽입 정렬의 약점
            - 오름차순 정렬 기준, 내림차순으로 구성된 데이터에 대해서는 앞의 데이터와 하나씩 비교하며 모두 교환 필요
        + 이전의 모든 데이터와 비교하지 않고 일정 간격을 드어 비교
        + 알고리즘 복잡도 O(N^2)
***
3. 이진 탐색
    + 정렬된 상태의 데이터에서 특정 값을 빠르게 탐색하는 방법
        - 찾고자 하는 값과 데이터 중앙에 있는 값을 비교
        - 찾고자 하는 값이 더 작으면 데이터 왼쪽 부분에서 이진 탐색
        - 찾고자 하는 값이 더 크면 데이터 오른쪽 부분에서 탐색
4. 투 포인터
    + 배열 에서 두개의 포인터를 사용하여 언하는 결과를 얻는 방법
    + 두 개 포인터의 배치 방법
        - 같은 방향에서 시작 : 첫 번째 원소에 둘 다 배치
        - 서로 다른 방향에서 시작 : 첫 번 째 원소와 마지막 원소에 배치
    + 다중 for 문의 복잡도를 좀 더 선형적으로 풀 수 있음
5. 그리디 알고리즘
    + 매 순간 현재 기준으로 최선의 답을 선택해 나가는 기법
        - 빠르게 근사치를 계산할 수 있다
        - 결과적으로는 최적해가 아닐 수도 있다.
    + 그리디 알고리즘 적용 조건
        - 그리디 알고리즘은 빠르지만 최적해를 보장하지는 못함
        - 하기 두가지 조건에 해당하는 경우 적용 가능
            - 탐욕적 선택 특성
                - 지금 선택이 다음 선택에 영향을 주지 않음
            - 최적 부분 구조
                - 전체 문제의 최적해는 부분 문제의 최적해로 이루어짐
6. 분할 정복
    + 큰 문제를 작은 부분 문제로 나누어 해결하는 방법
        - 합병 정렬,퀵 정렬, 이진 탐색, ...
    + 분할 정복 과정
        - 문제를 하나 이상의 작은 부분들로 분할
        - 부분들을 각각 정복
        - 부분들의 해답을 통합하여 원래 문제의 답을 구함
    + 장점
        - 문제를 나누어 처리하며 어려운 문제 해결 가능
        - 병렬처리에 이점이 있음
    + 단점
        - 메모리를 많이 사용(재귀 호출 구조)
7. 다이나믹 프로그래밍
    + 큰 문제를 부분 문제로 나눈 후 답을 찾아가는 과정에서, 계산된 결과를 기록하고 재활용하며 문제의 답을 구하는 방식
    + 중간 계산 결과를 기록하기 위한 메모리가 필요
    + 한번 계산한 부분을 다시 계산하지 않아 속도가 빠름
    + 분할 정복과 차이
        - 분할 정복은 부분 문제가 중복되지 않음
        - DP는 부분 문제가 중복되어 재활용에 사용
    + 그리디 알고리즘과의 차이
        - 그리디 알고리즘은 순간의 최선을 구하는 방식(근사치)
        - DP는 모든 방법을 확인 후 최적해를 구하는 방식
    + 타뷸레이션
        - 상향식 접근 방법
        - 작은 하위 문제부터 풀면서 올라감
        - 모두 계산하면서 차례대로 차례대로 진행
    + 메모이 제이션
        - 하향식 접근 방법
        - 큰 문제에서 하위 문제를 확인해가며 진행
        - 계산이 필요한 순간 계산하며 진행
8. 백트레킹
    + 모든 경우의 수를 탐색하며 최적해를 구하는 과정에서 유망하지 않은 쪽은 더 이상 구하지 않는 방법
    + 용어
        - 유망 : 해가 될 가능성이 있는 경우 유망하다고 함
        - 가지치기 : 해가 될 가능성이 없는 경우 해당 노드를 제외 하는 것
        - 백트래킹 : 유망하지 않은 쪽으로 가지 않고 되돌아 오는 것
9. 최단 경로 알고리즘
    + 가중 그래프 상의 두 노드를 연결하는 가장 짧은 경로를 찾는 방법
    + 지도 경로 탐색, 네트워크 구축에 드는 비용을 최소화 하는데 사용
    + 최단 경로 알고리즘
        - 다익스트라
        - 벨만-포드
        - 플로이드-워셜
    + 다익스트라
        - 출발점에서 목표점까지의 최단 경로를 구하는 알고리즘
        - 한 노드에서 다른 모든 노드로의 최단 경로를 구할 수 있음
        - 간선에 음의 가중치가 없어야함
        - 그리디 + DP 형태
        - 알고리즘 복잡도: O(ElogV)
    + 벨만-포드
        - 음수 간선이 포함되어 있어도 최단 경로 구할 수 있음
            - 음수 사이클이 있으면 정상 동작하지 않음
            - 음수 사이클 체크를 통해 잘못된 그래프라는걸 알수 있다
        - 매번 모든 간선을 확인하기 때문에 다익스트라에 비해 느림
        - 알고리즘 복잡도 : O(VE)
    + 플로이드-워셜
        - 모든 노드 간의 최단 경로를 구하는 알고리즘
        - 음의 간선이 포함되어 있어도 사용가능
            - 음수 사이클이 있으면 정상 동작 하지 않음
            - 노드 수 V일때 V*V만큼의 메모리 필요
            - 모든 노드에서 모든 노드로 가는 경로 DP 방식 업데이트
            - 음수 사이클 체크(다 돌았을때 자기 자신으로 가는게 값이 생김)
        - 알고리즘 복잡도 : O(V^3)
10. 최소 신장 트리
    + MST : Minimum Spanning Tree
    + 그래프 상의 모든 노드들을 최소 비용으로 연결하는 방법
        - 크루스칼, 프림
    + 크루스칼
        - 간선 중 최소값을 가진 간선부터 연결
        - 사이클 발생 시 다른 간선 선택
        - 주로 간선 수가 적을 때 사용
        - O(ElogE)
        - 이 알고리즘은 간선들만 본다.
        - 사이클 발생 체크 방법
            - Union Find 방법
                - 최종 부모노드 그러니까 가장 윗 부모가 같은지 확인하는 방법
    + 프림
        - 임의의 노드에서 시작
        - 연결된 노드들의 간선 중 낮은 가중치를 갖는 간선 선택
        - 간선의 개수가 많을 때 크루스칼 보다 유리
        - O(ElogV)
        - priority queue와 visited 배열을 사용 