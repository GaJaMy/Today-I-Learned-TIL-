# 운영체제
1. 운영체제란?
    - OS(Operating System) - 정확히는 커널을 의미, 통상적으로는 커널에 여러가지가 추가된 것(사용자, 응용프로그램, 커널, 하드웨어)
        - 커널이란? - 컴퓨터 운영 체제의 핵심이 되는 컴퓨터 프로그램으로, 시스템 모든 것을 완전히 통제하는 프로그램 
        - 커널의 역할
            - 보안 - 컴퓨터 하드웨어와 프로세스의 보안을 책임
            - 자원 관리 - 한정된 시스템 자원을 효율적으로 관리하여 프로그램의 실행을 원활하게 한다. 특히 프로세스에 처리기를 할당(스케쥴링)
            - 추상화 - 운영 체제의 복잡한 내부를 감추고 깔끔하고 일관성 있는 인터페이스를 하드웨어에 제공하기 위해 하드웨어 추상화 들을 구현
                - 즉, 하드웨어가 달라도 프로그래머가 여러장비에서 작동하는 프로그램을 개발 할 수 잇는 이유다.
        - 쉘 - 사용자가 운영체제 기능과 서비스를 조작할 수 있도록 인터페이스를 제공하는 프로그램(응용 프로그램)
        - 시스템 콜 - 운영체제가 운영체제의 각 기능을 사용할 수 있도록 시스템 콜이라는 명령 또는 함수를 제공 - API나 Library를 제공
        - API(Application Programming Interface) - 일종의 함수를 일컫는다. API 내부에는 필요시 해당 운영체제의 시스템콜을 호출하는 형태로 만들어 짐
***
2. 사용자 모드와 커널모드
    + 컴퓨터에 영향을 미칠 수 있는 어떤 동작을 사용자에게 주면 실수로 인해서 컴퓨터 시스템 자체에 문제가 생길 수 있다. 이를 방지하기 위해 운영체제 코드를 실행 하는 커널 모드와 사용자 응용 프로그램을 사용하는 사용자 모드로 나누어 두었다.
        - 사용자 모드 - 사용자를 위해 실행되는 작업을 할 때 운영체제가 전환 되는 모드
            - 작업을 수행 하던중 운영체제 기능(ex: 메모리를 지우는 작업 같은 중요한 작업)을 사용 할 때가 오면 시스템 콜을 발생
            - 커널 모드에서 운영체제가 작업을 함
            - 작업을 마친후 다시 사용자 모드로 복귀
        - 커널 모드 - 운영체제 코드를 실행하는 작업(OS)
            - 사용자 모드에서 시스템 콜에 의해 커널 모드로 바뀜(인터럽트 발생)
            - 운영체제가 작업을 다하면 다시 인터럽트를 발생 시켜 사용자 모드로 전환
    + \*CPU 자체에서 모드 변경을 제공한다. 참고:[CPU Protection Ring](https://ko.wikipedia.org/wiki/%EB%B3%B4%ED%98%B8_%EB%A7%81)
***
3. 운영체제의 역할
    + 시스템 자원 관리 - 시스템 자원(컴퓨터 하드웨어)
        - CPU,Memory
        - IO Device
        - Storage
    + 사용자와 컴퓨터간의 커뮤니케이션 지원
    + 응용 프로그램 제어
***
4. 응용 프로그램이란?
    + 프로그램 = 소프트웨어
    + 소프트웨어 = 운영체제, 응용프로그램
    + 응용 프로그램 = 운영체제 위에서 돌아가는 프로그램을 응용 프로그램
        - 운영 체제는 응용 프로그램을 관리하는 데 주로 아래와 같은 역할을 한다.
            - 실행
            - 권한 관리 (관리자 권한으로 실행)
            - 사용자 관리 (로그인)
***
5. 프로세스 - 실행 중인 프로그램
    + 프로세스 : 메모리에 올려져서, 실행 중인 프로그램
    + 코드 이미지(바이너리) : 실행파일
    + 응용 프로그램은 프로세스가 아니다!
        - 응용 프로그램은 여러 프로세스로 구성 가능
    + 배치 처리 시스템
        - 여러 프로그램을 순차적으로 실행 시킬 수 잇도록 하는 시스템
        - 어떤 프로그램은 실행이 너무 시간이 많이 걸려 다른 프로그램이 실행 하는데 시간을 많이 기다려야함 - 배치 처리 시스템의 단점
        - 먼저, 여러가지 프로세스를 등록시켜 놓으면 운영체제가 알아서 빠른 것 부터 실행 시킨다 => 배치 처리 시스템
    + 시분할 시스템 - 다중 사용자 지원을 위해 컴퓨터 응답 시간을 최소화 하는 시스템
        - 만약, 서버에 접속해서 어떤 작업을 하려는데 배치 처리 시스템이면 이전에 접속했던 사람이 끝날 때까지 기다릴 수 밖에 없다.
        - 이를 해결하기 위해 응용 프로그램이 CPU를 점유하는 시간을 잘게 쪼게어 실행 할 수 있도록 한다.
        - 간단히, 각 응용 프로그램마다 CPU를 점유하는 시간을 균일하게 짧게 줘서 처리,처리,처리를 통해 다중 사용자가 동시에 사용하는 것 처럼 보이게 만든다.
    + 멀티 태스킹
        - 단일 CPU에서, 여러 응용 프로그램이 동시에 실행되는 것처럼 보이도록 하는 기술 (시분할 시스템과 개념 자체는 비슷하다.)
        - 시분할 시스템은 같은 작업에 대한 Needs라면, 멀티 테스킹은 여러 작업이 가능 하도록 하는 것에 대한 것이다.
    + 멀티 프로그래밍
        - 최대한 CPU를 많이 활용하도록 하는 시스템
        - 예를 들면 A라는 프로세스가 저장 메체에 접근해서 파일을 가져오는데 시간이 오래걸려 CPU가 놀고 있으면 매우 비효율적 -> 그래서 그 시간동안 다른 프로세스의 작업을 해당 시간에 넣어 둠 => 이로 인해 CPU가 100%활용 가능
    + 멀티 태스킹 vs 멀티 프로세싱
        - 멀티 태스킹 : 단일 CPU
        - 멀티 프로세싱 : 여러 CPU에 하나의 프로그램을 병렬로 실행해서 실행속도를 그대화 시키는 시스템
***
6. 스케쥴러와 프로세스
    + 스케쥴러 - 프로세스 실행 관리 :  운영체제 ->  커널 -> 스케쥴러
        - 스케쥴링 알고리즘 - 프로세스 응답 시간을 짧게(시분할 시스템), CPU활용도 최대(멀티 프로그래밍)
        - FIFO 스케쥴러 -  가장 간단한 스케쥴러 (배치 처리 시스템), 먼저 들어온걸 먼저 실행 시킨다.
        - 최단 작업 우선(SJF) 스케쥴러 - 가장 프로세스 실행 시간이 짧은 프로세스 부터 먼저 실행을 시키는 알고리즘</br></br>
        \* RealTime OS(RTOS) : 응용 프로그램 실시간 성능 보장을 목표로 하는 OS - HardwarRTOS, SoftWare RTOS
        </br>
        \* Genearl Purpose OS(GPOS) : 프로세스 실행시간에 민감하지 않고, 일반적인 목적으로 사용되는 OS = Windows, Linux 등
        </br>
        - 우선순위 기반 스케쥴러 - 우선 순위를 정해 스케쥴링 하는 기법 , 정적 우선순위와 동적 우선 순위
            - 정적 우선순위 - 프로세스마다 우선순위를 미리 지정
            - 동적 우선순위 - 스케쥴러가 상황에 따라 우선순위를 동적으로 변경(한번도 작업 안된 녀석을 우선으로)
        - RR(Round Robin) 스케쥴러
            - 각 프로세스 마다 작업이 담긴 큐가 존재하고 프로세서는 하나씩 빼서 작업을 한다. 만약 해당 작업이 너무 오래 걸리면 다시 큐에 넣어서 나중에 작업을 할 수 있도록 하는 스케쥴링 방법
        - 프로세스 상태 기반 스케쥴러 - 프로세스에 상태 정보를 넣는 것(멀티 프로그래밍)
            - runnig state : 현재 CPU에서 실행 상태 
            - ready state : CPU에서 실행 가능 상태(실행 대기 상태)(큐로 구현 되어 있다.)
            - block state : 특정 이벤트 발생 대기 상태
    + 프로세스
        - 구조
            - text : 코드 - 바이너리 코드
            - data : 변수/ 초기화된 데이터
            - stack: 임시 데이터(함수 호출, 로컬 변수 등)
                - stack 공간은 한정된 공간이기 때문에 재귀함수가 계속해서 불리게 되면 에러가 발생 한다.
            - heap : 코드에서 동적으로 만들어지는 데이터
                - 메모리에 동적으로 할당하는 경우 heap메모리에 할당 된다. heap도 한정이 되어 있지만 유동적이라서 객체가 더이상 엑세스 하지 않거나 하면 커지고 작아지고를 반복한다.
        - PC(Program Counter) -  다음 실행할 코드 주소를 가짐
        - SP(Stack Pointer) - 스택 최상당 주소
        - 임베디드 시스템등에서 동작하는 C 프로그램등은 디버깅시 PC와 SP를 캡쳐해서 확인
        - 해당 명령 구조의 변환 내용은 포함된 엑셀 문서 확인
    + 컨택스트 스위칭 - CPU에 실행할 프로세스를 교체하는 기술
        - 바로 위에서 다룬 내용이 하나의 프로세스에 대한 내용이라면 아래는 프로세스 간의 내용
        - 아이디어는 PC와 SP정보를 따로 어딘가에 프로세스 마다 저장해 두면 가능하다.
            - PCB에 다음 프로세스 정보를 저장
                - Process ID(프로세스에 대한 번호) , Register (PC, SP등)등
        1. 실행 중지할 프로세스 정보를 해당 프로세스의 PCB에 업데이트해서, 메인 메모리에 저장
        2. 다음 실행할 프로세스 정보를 메인 메모리에 있는 해당 PCB정보를 CPU의 레지스터에 넣고 실행
    + 멀티 프로세스와 IPC(InterProcess Communication)
        - 하나의 프로세스는 다른 프로세스의 공간을 접근 할 수 없다.
        - 이를 해결하기 위해 서로 프로세스간 통신이 필요 => IPC의 탄생
        - IPC - 프로세스간 통신 방법을 제공함
            1. 파일을 공유하여 통신 - 단점 파일이 변경 되었다를 알려줄 수 없음
            2. 가상 메모리를 이용하여 통신 - 커널 공간을 공유한다.
                1. 1 Message Queue
                    - 커널 공간에 메모리를 만들고, 해당 공간을 변수처럼 쓰는 방식
                1. 2 Shared Memory
                    - 커널 공간에 메모리를 만들고, 해당 공간을 변수처럼 쓰는 방식
                1. 3 Pipe
                    - 커널 공간에 메모리를 만들고, 해당 공간을 변수처럼 쓰는 방식
                1. 4 Signal
                1. 5 Semaphore
                1. 6 Socket
***
7. 스레드 - 여러개의 프로세스는 서로 테이터를 공유 할 수 없기 때문에 IPC라는 통신 기술로 통신을 해야 했다.
    - 이를 해결하기 위해 스레드가 등장한다.
    - 스레드는 하나의 프로세스 안에서 동작한다. 하나의 프로세스안에서 여러개의 스레드 생성 가능
    - 즉, 스레드는 멀티 프로세스처럼 여러 코어에 작업들을 분산 시키는것이다.(멀티 프로세스는 프로세스를 여러코어에 스레드는 하나의 프로세스의 작업을 여러 코어에)
    - 각 스레드 마다 별도의 Stack 영역이 있다.(다른 영역은 공유 한다.) => 이것은 프로세스의 Stack 영역을 쪼개서 가지고 있다.(즉, 완전 다른 프로세스 영역에 Stack 영역을 가지지는 않는다.)
    - 스레드 장점
        - 사용자에 대한 응답성 향상 : 프로그램에 어떤 요청을 했을때, 반응하는 것이 향상
        - 자원 공유 효율 : 프로세스 안에 있으므로, 프로세스 데이터를 모두 접근 가능하다. 즉, 여러게의 자원을 만들 필요가 없다.
        - 작업이 분리되어 코드가 간결해진다 : 사실 개발자 나름임...ㅋㅋ
    - 스레드 단점
        - 스레드 중 한 스레드만 문제가 있어도 , 저체 프로세스가 영향을 받음
        - Context Switching이 많이 일어나, 성능이 저하된다.
        - 동기화 이슈로 비정상적으로 동작 가능 :  동기화 코드를 적절히 추가해줘야 한다.
    - 스레드 동기화(Synchronization) - 작업들 사이에 실행 시기를 맞추는 것
        - 여러 스레드가 동일한 자원 접근시 동기화 이슈 발생
        - 해결 방안
            - Mutual exlcusion(상호 배제)
                - 스레드는 프로세스 모든 데이터를 접근 할 수 있다.
                - 여러 스레드가 변경하는 공유 변수에 대해 Exclusive Access 필요
                - 어느 한 스레드가 공유 변수를 갱신하는 동안 다른 스레드가 동시 접근하지 못하도록 막음
                    - citical resource - 임계 자원으로 동시에 공유하는 데이터
                    - citical section - 임계 자원을 접근하는 곳으로 스레드가 서로 침범하지 못하도록 하는 영역
            - mutex
                - Critical Section에 대한 접근을 막기 위해 Locking 메커니즘 을 사용
            - semaphore
                - 임계 구역에 여러 스레드가 들어갈 수 있음
                - counter를 두어서 동시에 리소스에 접근 할 수 있는 허용 가능한 스레드 수를 제어
    - Deadlock과 Starvation
        - Deadlock - 두 개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있기 때문에, 다음 단계로 진해아지 못하는 상태
        - Starvation - 특정 프로세스의 우선순위가 낮아서 원하는 자원을 계속 할당 받지 봇하는 상태
            - 사실 스레드와는 관련이 없지만 데드락과 비슷하기 때문에 묶어 놓음
***
8. 가상 메모리(Virtual Memory System) - 메모리가 실제 메모리보다 많아 보이게 하는 기술
    + 실제 각 프로세스마다 충분한 메모리를 할당하기에는 메모리 크기가 한계가 있음, 그래서 가상 메모리를 사용함
    + 하나의 프로세스만 실행 가능한 시스템(배치 처리 시스템)에서는 필요가 없지만, 여러 프로세스 동시 실행 시스템인 경우 메모리 용량이 부족할 수 가 있다.
    + 실제 사용하는 메모리는 작다는 점에 착안해서 고안된 기술
    + 프로세스간 공간 분리로, 프로세스 이슈가 전체 시스템에 영향을 주지 않을 수 있음
    + 기본 아이디어
        - 프로세스는 가상 주소를 사용하고, 실제 해당 주소에서 데이터를 읽고/쓸때만 물리 주소로 바꿔준다.
        - virtual address : 프로세스가 참조하는 주소
        - physical address : 실제 메모리 주소
    + MMU(Memory Management Unit)
            - CPU 코드 실행 시, 가상 주소 메모리 접근이 필요할 때, 해당 주소를 무리 주소값으로 변환해주는 하드웨어 장치
            - 메인 메모리에 실제 각 프로세스의 데이터가 조각으로 씌여 있다.
    + 페이징 시스템(paging system)
        - 페이징 개념
            - 크기가 동일한 페이지로 가상 주소 공간과 이에 매칭하는 물리 주소 공간을 관리
            - 하드웨어 지원이 필요
            - 리눅스에서는 4KB로 paging
            - 페이지 번호를 기반으로 가상 주소/물리 주소 매핑 정보를 기록/사용
        - 페이징 시스템 구조
            - 페이지 또는 페이지 프레임 : 고정된 크기의 block(4KB)
            - 페이징 시스템
                - 가상주소 v = (p,d)
                    - p: 가상 메모리 페이지
                    - d: p안에서 참조하는 위치
            - 페이지 크기가 4KB의 예
                - 가상 주소의 0비트에서 11비트가 변위(d)를 나타내고,
                - 12비트 이상의 페이지 번호가 될 수 있음
            - 페이지 테이블 = 물리 주소에 있는 페이지 번호와 해당 페이지의 첫 물리 주소 정보를 매핑한 표
            - 동작
                - 해당 프로세스에서 특정 가상 주소에 엑세스를 하려면
                    - 해당 프로세스의 페이지 테이블에 해당 가상 주소가 포함된 페이지 번호가 있는지 확인
                    - 페이지 번호가 있으면 이 페이지가 매핑된 첫 물리 주소를 알아내고
                    - 매핑된 첫 주소에 변위 만큼을 더해 실제 물리 주소를 알아냄
                - CPU는 가상 주소 접근시 MMU 하드웨어 장치를 통해 물리 메모리 접근
                - 프로세스 생성시, 페이지 테이블 정보 생성
                    - PCB등에서 해당 페이지 테이블 접근 가능하고, 관련 정보는 물리 메모리에 적재
                    - 프로세스 구동시, 해당 페이지 테이블 베이스 주소가 별도 레지스터에 저장
                    - CPU가 가상 주소 접근시 MMU가 페이지 테이블 베이스 주소를 접근해서, 물리 주소를 가져옴
    + MMU와 TLB
        - TLB(Translation Lookaside Buffer) - 페이지 정보 캐쉬 : 최근에 CPU가 요청한 페이지의 물리 주소를 가지고 있음, 그 이유는 메모리에 접근할때 엄청난 시간이 필요하기 때문에 최근에 접근한 가상 정보에 대한 정보를 캐쉬영역에 가지고 잇으면 바로 접근해서 메모리를 한번만 접근하도록 함
    + 페이징 시스템과 공유 메모리 (IPC)
        - 프로세스간 동일한 물리 주소를 가리킬 수 있음 (공간 절약, 메모리 할당 시간 절약)
    + 요구 페이징(Demand Pagin 또는 Demanded Paging)
        - 프로세스 모든 데이터를 메모리로 적제하지 않고, 실행 중 필요한 시점에만 메모리로 적재함
            - 선행 페이징의 반대 개념으로 미리 프로세스 관련 데이터를 메모리에 올려 놓고 실행하는 개념
            - 더 이상 필요하지 않은 페이지 프레임은 다시 저장매체에 저장(페이지 교체 알고리즘 필요)
        - 페이지 폴트
            - 어떤 페이지가 실제 물리 메모리에 없을 때, 일어나는 인터럽트
            - 운영체제가 페이지 폴트가 일어나면 해당 패이지를 물리 메모리에 올림
    + 사용자/커널 모드와 프로세스, 인터럽트
        - 시스템 콜, 타이머 인터럽트
        - 타이머 인터럽트 - 하나의 프로세스가 실행 할수 있는 시간을 체크하고, 시간이 만료가 되면 인터럽트가 발생 하여 프로세스가 바뀐다.
    + 인터럽트와 IDT
        - 인터럽트는 미리 정의되어 각각 번호와 실행 코드를 가리키는 주소가 기록되어있음
            - IDT에 기록 되어 있음
            - 컴퓨터 부팅시 운영체제가 기록
            - 운영체제 내부코드로 구현 되어 있음
    + 페이지 교체 정책
        - 운영체제가 특정 페이지를 물리 메모리에 올려 놔야하는데, 물리 메모리가 다 차있다면
            - 기존 페이지 중 하나를 물리 메모리에서 저장 매체로 내리고(저장)
            - 새로운 페이지를 해당 물리 메모리 공간에 올린다.
        - FIFO - 가장 먼저 들어온 페이지를 내리는 방법
        - OPT - 앞으로 가장 오랫동안 사용하지 않을 페이지를 내리자, 미래 예측, 일반 OS에서는 구현이 불가능 하다.
        - LRU(Least Recently Used) - 가장 오래 전에 사용된 페이지를 교체, OPT 알고리즘이 구현이 불가능 하므로, 과거 기록을 기반으로 시도한다.
        - LFU(Least Frequntly Userd) - 가장 덜 사용된 페이지를 내리자
        - NUR - LRU와 마찬가지로 최근에 사용하지 않은 페이지 부터 교체하는 기법, 각 페이지 마다 참조 비트(R), 수정 비트(M)을 둠(0,0),(0,1),(1,0),(1,1)순서로 교체
    + 전체적인 페이징 시스템 동작
        1. 페이지가 실제 물리 메모리에 있을 때
            1. CPU가 MMU에 가상 주소를 요청 한다.
            2. MMU는 TLB(캐쉬)를 확인
            3. 만약 TLB에 있으면 바로 메모리에 접근하여, 해당 물리 주소를 CPU에 전달
            4. TLB에 없으면 메모리에서 페이지 테이블 확인
            5. 테이블에 명시된 메모리 물리 주소를 확인 후 CPU에 전달
        2. 페이지가 실제 물리 메모리에 없을 때
            1. CPU가 MMU에 가상 주소 요청
            2. MMU가 TLB 확인
            3. 만약 TLB에 있으면 바로 메모리에 접근하여, 해당 물리 주소를 CPU에 전달
            4. TLB에 없으면 메모리에서 페이지 테이블 확인
            5. 해당하는 페이지가 Invalid한 걸 확인 후 OS에 페이지 폴트 인터럽트 발생
            6. 이걸 인지한 OS가 저장 매체에서 해당하는 페이지를 찾음
            7. 찾은 후 메모리에 적재후 페이지 테이블 갱신(업데이트)
            8. OS는 업데이트 되었다는 것을 CPU에 전달
            9. CPU는 다시 1번부터 재시작
***
9. 파일 시스템 개념 이해
    + 파일 시스템 - 운영체제가 저장매체에 파일을 쓰기 위한 자료구조 또는 알고리즘